This patch provides methods to EST_Wave for saving wave files 
by parts, either writing only the file header or the actual data.
Additionally it provides a function to write a wave file header without
having an EST_Wave instance.

This patch can be used (for instance by festival). On Festival-2.1 the way
text2wave works is as follows: Given a long text, it is split in utterances
which are saved in temporal files. At the end, all temporal files are loaded
into memory and appended in memory one by one, and finally dumped to the 
output file.
This approach required double the disk i/o (temporal files and final file) and
required to have the whole synthesized text loaded in memory.

By using this patch, text2wave can be improved so as utterances are written
directly to the final file reducing both disk i/o and memory usage at once.

Backwards compatibility is preserved.

No copyright is claimed on this patch, in order to make it easier to 
merge with upstream, although attribution is appreciated :-)

Author: Sergio Oller <sergioller@gmail.com>
Applied-Upstream: https://github.com/festvox/speech_tools/pull/24

--- a/include/EST_Wave.h
+++ b/include/EST_Wave.h
@@ -298,11 +298,18 @@ public:
 
   EST_write_status save_file(const EST_String filename, 
 			     EST_String filetype,
-			     EST_String sample_type, int bo);
+			     EST_String sample_type, int bo, const char *mode = "wb");
 
   EST_write_status save_file(FILE *fp,
 			     EST_String filetype,
 			     EST_String sample_type, int bo);
+
+  EST_write_status save_file_header(FILE *fp,
+				     EST_String ftype,
+				     EST_String stype, int obo);
+  EST_write_status save_file_data(FILE *fp,
+				     EST_String ftype,
+				     EST_String stype, int obo);
   //@}
 
   /// Assignment operator
--- a/include/EST_wave_aux.h
+++ b/include/EST_wave_aux.h
@@ -116,6 +116,13 @@ enum EST_sample_type_t {
   st_alaw, 
   st_ascii};
 
+
+enum EST_write_status wave_io_save_header(FILE *fp,
+                      const int num_samples, const int num_channels,
+                      const int sample_rate,
+                      const EST_String& stype, const int bo,
+                      const EST_String& ftype);
+
 extern EST_TNamedEnum<EST_sample_type_t> EST_sample_type_map;
 
 #endif /* __EST_WAVE_AUX_H__ */
--- a/speech_class/EST_Wave.cc
+++ b/speech_class/EST_Wave.cc
@@ -394,13 +394,13 @@ EST_write_status EST_Wave::save(FILE *fp
 
 EST_write_status EST_Wave::save_file(const EST_String filename,
 				     EST_String ftype,
-				     EST_String stype, int obo)
+				     EST_String stype, int obo, const char *mode)
 {
     FILE *fp;
 
     if (filename == "-")
 	fp = stdout;
-    else if ((fp = fopen(filename,"wb")) == NULL)
+    else if ((fp = fopen(filename, mode)) == NULL)
     {
 	cerr << "Wave save: can't open output file \"" <<
 	    filename << "\"" << endl;
@@ -435,7 +435,55 @@ EST_write_status EST_Wave::save_file(FIL
     }
     
     return (*s_fun)(fp, *this, sample_type, obo);
+}
+
+EST_write_status EST_Wave::save_file_data(FILE *fp,
+				     EST_String ftype,
+				     EST_String stype, int obo)
+{
+    EST_WaveFileType t = EST_WaveFile::map.token(ftype);
+    EST_sample_type_t sample_type = EST_sample_type_map.token(stype);
+
+    if (t == wff_none)
+      {
+	cerr << "Unknown Wave file type " << ftype << endl;
+	return write_fail;
+      }
+
+    EST_WaveFile::Save_TokenStream * s_fun = EST_WaveFile::map.info(t).save_data;
     
+    if (s_fun == NULL)
+    {
+	cerr << "Can't save wave data to files type " << ftype << endl;
+	return write_fail;
+    }
+
+    return (*s_fun)(fp, *this, sample_type, obo);
+}
+
+
+EST_write_status EST_Wave::save_file_header(FILE *fp,
+				     EST_String ftype,
+				     EST_String stype, int obo)
+{
+    EST_WaveFileType t = EST_WaveFile::map.token(ftype);
+    EST_sample_type_t sample_type = EST_sample_type_map.token(stype);
+
+    if (t == wff_none)
+      {
+	cerr << "Unknown Wave file type " << ftype << endl;
+	return write_fail;
+      }
+
+    EST_WaveFile::Save_TokenStream * s_fun = EST_WaveFile::map.info(t).save_header;
+
+    if (s_fun == NULL)
+    {
+	cerr << "Can't save wave header to files type " << ftype << endl;
+	return write_fail;
+    }
+
+    return (*s_fun)(fp, *this, sample_type, obo);
 }
 
 void EST_Wave::resample(int new_freq)
--- a/speech_class/waveP.h
+++ b/speech_class/waveP.h
@@ -51,7 +51,17 @@ enum EST_read_status load_wave_raw(EST_T
 enum EST_write_status save_wave_raw(FILE *fp, const short *data, int offset,
 			       int num_samples, int num_channels, 
 			       int sample_rate,
-			       enum EST_sample_type_t sample_type, int bo)   ;
+			       enum EST_sample_type_t sample_type, int bo);
+
+enum EST_write_status save_wave_raw_header(FILE *fp,
+				int num_samples, int num_channels,
+				int sample_rate,
+				enum EST_sample_type_t sample_type, int bo);
+
+enum EST_write_status save_wave_raw_data(FILE *fp, const short *data, int offset,
+				int num_samples, int num_channels,
+				int sample_rate,
+				enum EST_sample_type_t sample_type, int bo);
 
 enum EST_read_status load_wave_ulaw(EST_TokenStream &ts, short **data, int
 	 *num_samples, int *num_channels, int *word_size, int
@@ -62,6 +72,16 @@ enum EST_write_status save_wave_ulaw(FIL
 				int sample_rate,
 				enum EST_sample_type_t, int bo);
 
+enum EST_write_status save_wave_ulaw_header(FILE *fp,
+				int num_samples, int num_channels,
+				int sample_rate,
+				enum EST_sample_type_t sample_type, int bo);
+
+enum EST_write_status save_wave_ulaw_data(FILE *fp, const short *data, int offset,
+				int num_samples, int num_channels,
+				int sample_rate,
+				enum EST_sample_type_t sample_type, int bo);
+
 enum EST_read_status load_wave_alaw(EST_TokenStream &ts, short **data, int
 	 *num_samples, int *num_channels, int *word_size, int
 	 *sample_rate,  enum EST_sample_type_t *sample_type, int *bo, int
@@ -81,6 +101,16 @@ enum EST_write_status save_wave_nist(FIL
 			       int sample_rate,
 			       enum EST_sample_type_t sample_type, int bo);
 
+enum EST_write_status save_wave_nist_header(FILE *fp,
+				int num_samples, int num_channels,
+				int sample_rate,
+				enum EST_sample_type_t sample_type, int bo);
+
+enum EST_write_status save_wave_nist_data(FILE *fp, const short *data, int offset,
+				int num_samples, int num_channels,
+				int sample_rate,
+				enum EST_sample_type_t sample_type, int bo);
+
 enum EST_read_status load_wave_est(EST_TokenStream &ts, short **data, int
 	 *num_samples, int *num_channels, int *word_size, int
 	 *sample_rate,  enum EST_sample_type_t *sample_type, int *bo, int
@@ -91,6 +121,16 @@ enum EST_write_status save_wave_est(FILE
 			       int sample_rate,
 			       enum EST_sample_type_t sample_type, int bo);
 
+enum EST_write_status save_wave_est_header(FILE *fp,
+				int num_samples, int num_channels,
+				int sample_rate,
+				enum EST_sample_type_t sample_type, int bo);
+
+enum EST_write_status save_wave_est_data(FILE *fp, const short *data, int offset,
+				int num_samples, int num_channels,
+				int sample_rate,
+				enum EST_sample_type_t sample_type, int bo);
+
 enum EST_read_status load_wave_sd(EST_TokenStream &ts, short **data, int
 	 *num_samples, int *num_channels, int *word_size, int
 	 *sample_rate,  enum EST_sample_type_t *sample_type, int *bo, int
@@ -101,6 +141,16 @@ enum EST_write_status save_wave_sd(FILE
 			      int sample_rate, 
 			      enum EST_sample_type_t sample_type, int bo);
 
+enum EST_write_status save_wave_sd_header(FILE *fp,
+				int num_samples, int num_channels,
+				int sample_rate,
+				enum EST_sample_type_t sample_type, int bo);
+
+enum EST_write_status save_wave_sd_data(FILE *fp, const short *data, int offset,
+				int num_samples, int num_channels,
+				int sample_rate,
+				enum EST_sample_type_t sample_type, int bo);
+
 enum EST_read_status load_wave_audlab(EST_TokenStream &ts, short **data, int
 	 *num_samples, int *num_channels, int *word_size, int
 	 *sample_rate,  enum EST_sample_type_t *sample_type, int *bo, int
@@ -111,6 +161,16 @@ enum EST_write_status save_wave_audlab(F
 			       int sample_rate, 
 			       enum EST_sample_type_t sample_type, int bo);
 
+enum EST_write_status save_wave_audlab_header(FILE *fp,
+				int num_samples, int num_channels,
+				int sample_rate,
+				enum EST_sample_type_t sample_type, int bo);
+
+enum EST_write_status save_wave_audlab_data(FILE *fp, const short *data, int offset,
+				int num_samples, int num_channels,
+				int sample_rate,
+				enum EST_sample_type_t sample_type, int bo);
+
 enum EST_read_status load_wave_snd(EST_TokenStream &ts, short **data, int
 	 *num_samples, int *num_channels, int *word_size, int
 	 *sample_rate,  enum EST_sample_type_t *sample_type, int *bo, int
@@ -121,6 +181,16 @@ enum EST_write_status save_wave_snd(FILE
 			       int sample_rate, 
 			       enum EST_sample_type_t sample_type, int bo);
 
+enum EST_write_status save_wave_snd_header(FILE *fp,
+				int num_samples, int num_channels,
+				int sample_rate,
+				enum EST_sample_type_t sample_type, int bo);
+
+enum EST_write_status save_wave_snd_data(FILE *fp, const short *data, int offset,
+				int num_samples, int num_channels,
+				int sample_rate,
+				enum EST_sample_type_t sample_type, int bo);
+
 enum EST_read_status load_wave_aiff(EST_TokenStream &ts, short **data, int
 	 *num_samples, int *num_channels, int *word_size, int
 	 *sample_rate,  enum EST_sample_type_t *sample_type, int *bo, int
@@ -131,6 +201,16 @@ enum EST_write_status save_wave_aiff(FIL
 				int sample_rate,
 				enum EST_sample_type_t sample_type, int bo);
 
+enum EST_write_status save_wave_aiff_header(FILE *fp,
+				int num_samples, int num_channels,
+				int sample_rate,
+				enum EST_sample_type_t sample_type, int bo);
+
+enum EST_write_status save_wave_aiff_data(FILE *fp, const short *data, int offset,
+				int num_samples, int num_channels,
+				int sample_rate,
+				enum EST_sample_type_t sample_type, int bo);
+
 enum EST_read_status load_wave_riff(EST_TokenStream &ts, short **data, int
 	 *num_samples, int *num_channels, int *word_size, int
 	 *sample_rate,  enum EST_sample_type_t *sample_type, int *bo, int
@@ -141,4 +221,14 @@ enum EST_write_status save_wave_riff(FIL
 				int sample_rate,
 				enum EST_sample_type_t sample_type, int bo);
 
+enum EST_write_status save_wave_riff_header(FILE *fp,
+				int num_samples, int num_channels,
+				int sample_rate,
+				enum EST_sample_type_t sample_type, int bo);
+
+enum EST_write_status save_wave_riff_data(FILE *fp, const short *data, int offset,
+				int num_samples, int num_channels,
+				int sample_rate,
+				enum EST_sample_type_t sample_type, int bo);
+
 #endif /* __EST_WAVEP_H__ */
--- a/speech_class/EST_WaveFile.cc
+++ b/speech_class/EST_WaveFile.cc
@@ -43,8 +43,8 @@
 #include "EST_cutils.h"
 #include "EST_Option.h"
 #include "EST_io_aux.h"
-#include "stdio.h"
-#include "math.h"
+#include <cstdio>
+#include <cmath>
 
 void extract(EST_Wave &sig, EST_Option &al);
 
@@ -62,7 +62,12 @@ EST_write_status (*standard_save_fn_fp)(
 				    int offset, int nsamp,
 				    int nchan, int srate,
 				    EST_sample_type_t stype, int bo);
-				    
+
+typedef
+EST_write_status (*standard_save_header_fn_fp)(FILE *fp,
+				    int nsamp,
+				    int nchan, int srate,
+				    EST_sample_type_t stype, int bo);
   
 static 
 EST_read_status load_using(standard_load_fn_fp fn,
@@ -106,6 +111,19 @@ EST_write_status status =  (*fn)(fp,
 return status; 
 }
 
+static
+EST_write_status save_header_using(standard_save_header_fn_fp fn,
+			    FILE *fp, const EST_Wave wv,
+			    EST_sample_type_t stype, int bo)
+{
+
+EST_write_status status =  (*fn)(fp,
+                wv.num_samples(), wv.num_channels(),
+				wv.sample_rate(),
+				stype, bo);
+return status;
+}
+
 EST_read_status EST_WaveFile::load_nist(EST_TokenStream &ts,
 			  EST_Wave &wv,
 			  int rate,
@@ -125,6 +143,20 @@ EST_write_status EST_WaveFile::save_nist
   return save_using(save_wave_nist, fp, wv, stype, bo);
 }
 
+EST_write_status EST_WaveFile::save_nist_data(FILE *fp,
+					 const EST_Wave &wv,
+					 EST_sample_type_t stype, int bo)
+{
+  return save_using(save_wave_nist_data, fp, wv, stype, bo);
+}
+
+EST_write_status EST_WaveFile::save_nist_header(FILE *fp,
+					 const EST_Wave &wv,
+					 EST_sample_type_t stype, int bo)
+{
+  return save_header_using(save_wave_nist_header, fp, wv, stype, bo);
+}
+
 EST_read_status EST_WaveFile::load_est(EST_TokenStream &ts,
 			  EST_Wave &wv,
 			  int rate,
@@ -146,7 +178,24 @@ EST_write_status EST_WaveFile::save_est(
   return save_using(save_wave_est,
 		    fp, wv,
 		    stype, bo);
+}
+
+EST_write_status EST_WaveFile::save_est_data(FILE *fp,
+					 const EST_Wave &wv,
+					 EST_sample_type_t stype, int bo)
+{
+  return save_using(save_wave_est_data,
+		    fp, wv,
+		    stype, bo);
+}
 
+EST_write_status EST_WaveFile::save_est_header(FILE *fp,
+					 const EST_Wave &wv,
+					 EST_sample_type_t stype, int bo)
+{
+  return save_header_using(save_wave_est_header,
+		    fp, wv,
+		    stype, bo);
 }
 
 EST_read_status EST_WaveFile::load_aiff(EST_TokenStream &ts, 
@@ -168,6 +217,19 @@ EST_write_status EST_WaveFile::save_aiff
   return save_using(save_wave_aiff, fp, wv, stype, bo);
 }
 
+EST_write_status EST_WaveFile::save_aiff_data(FILE *fp,
+					 const EST_Wave &wv,
+					 EST_sample_type_t stype, int bo)
+{
+  return save_using(save_wave_aiff_data, fp, wv, stype, bo);
+}
+
+EST_write_status EST_WaveFile::save_aiff_header(FILE *fp,
+					 const EST_Wave &wv,
+					 EST_sample_type_t stype, int bo)
+{
+  return save_header_using(save_wave_aiff_header, fp, wv, stype, bo);
+}
 
 EST_read_status EST_WaveFile::load_riff(EST_TokenStream &ts,
 			  EST_Wave &wv,
@@ -188,6 +250,19 @@ EST_write_status EST_WaveFile::save_riff
   return save_using(save_wave_riff, fp, wv, stype, bo);
 }
 
+EST_write_status EST_WaveFile::save_riff_data(FILE *fp,
+					 const EST_Wave &wv,
+					 EST_sample_type_t stype, int bo)
+{
+  return save_using(save_wave_riff_data, fp, wv, stype, bo);
+}
+
+EST_write_status EST_WaveFile::save_riff_header(FILE *fp,
+					 const EST_Wave &wv,
+					 EST_sample_type_t stype, int bo)
+{
+  return save_header_using(save_wave_riff_header, fp, wv, stype, bo);
+}
 
 EST_read_status EST_WaveFile::load_esps(EST_TokenStream &ts, 
 			  EST_Wave &wv,
@@ -210,6 +285,23 @@ EST_write_status EST_WaveFile::save_esps
 		    stype, bo);
 }
 
+EST_write_status EST_WaveFile::save_esps_data(FILE *fp,
+					 const EST_Wave &wv,
+					 EST_sample_type_t stype, int bo)
+{
+  return save_using(save_wave_sd_data,
+		    fp, wv,
+		    stype, bo);
+}
+
+EST_write_status EST_WaveFile::save_esps_header(FILE *fp,
+					 const EST_Wave &wv,
+					 EST_sample_type_t stype, int bo)
+{
+  return save_header_using(save_wave_sd_header,
+		    fp, wv,
+		    stype, bo);
+}
 
 EST_read_status EST_WaveFile::load_audlab(EST_TokenStream &ts, 
 			  EST_Wave &wv,
@@ -230,6 +322,19 @@ EST_write_status EST_WaveFile::save_audl
   return save_using(save_wave_audlab, fp, wv, stype, bo);
 }
 
+EST_write_status EST_WaveFile::save_audlab_data(FILE *fp,
+					 const EST_Wave &wv,
+					 EST_sample_type_t stype, int bo)
+{
+  return save_using(save_wave_audlab_data, fp, wv, stype, bo);
+}
+
+EST_write_status EST_WaveFile::save_audlab_header(FILE *fp,
+					 const EST_Wave &wv,
+					 EST_sample_type_t stype, int bo)
+{
+  return save_header_using(save_wave_audlab_header, fp, wv, stype, bo);
+}
 
 EST_read_status EST_WaveFile::load_snd(EST_TokenStream &ts, 
 			  EST_Wave &wv,
@@ -250,6 +355,21 @@ EST_write_status EST_WaveFile::save_snd(
   return save_using(save_wave_snd, fp, wv, stype, bo);
 }
 
+EST_write_status EST_WaveFile::save_snd_data(FILE *fp,
+					const EST_Wave &wv,
+					EST_sample_type_t stype, int bo)
+{
+  return save_using(save_wave_snd_data, fp, wv, stype, bo);
+}
+
+EST_write_status EST_WaveFile::save_snd_header(FILE *fp,
+					const EST_Wave &wv,
+					EST_sample_type_t stype, int bo)
+{
+  return save_header_using(save_wave_snd_header, fp, wv, stype, bo);
+}
+
+
 
 EST_read_status EST_WaveFile::load_raw(EST_TokenStream &ts, 
 			  EST_Wave &wv,
@@ -290,6 +410,20 @@ EST_write_status status =  save_wave_raw
 return status; 
 }
 
+EST_write_status EST_WaveFile::save_raw_data(FILE *fp,
+					 const EST_Wave &wv,
+					 EST_sample_type_t stype, int bo)
+{
+return save_raw(fp, wv, stype, bo);
+}
+
+
+EST_write_status EST_WaveFile::save_raw_header(FILE *fp,
+					 const EST_Wave &wv,
+					 EST_sample_type_t stype, int bo)
+{
+  return save_header_using(save_wave_raw_header, fp, wv, stype, bo);
+}
 
 EST_read_status EST_WaveFile::load_ulaw(EST_TokenStream &ts,
 			  EST_Wave &wv,
@@ -312,6 +446,25 @@ EST_write_status EST_WaveFile::save_ulaw
     return save_using(save_wave_ulaw, fp, localwv, stype, bo);
 }
 
+EST_write_status EST_WaveFile::save_ulaw_data(FILE *fp,
+					 const EST_Wave &wv,
+					 EST_sample_type_t stype, int bo)
+{
+    EST_Wave localwv = wv;
+    localwv.resample(8000);
+    return save_using(save_wave_ulaw_data, fp, localwv, stype, bo);
+}
+
+
+EST_write_status EST_WaveFile::save_ulaw_header(FILE *fp,
+					 const EST_Wave &wv,
+					 EST_sample_type_t stype, int bo)
+{
+    EST_Wave localwv = wv;
+    localwv.resample(8000);
+    return save_header_using(save_wave_ulaw_header, fp, localwv, stype, bo);
+}
+
 EST_read_status EST_WaveFile::load_alaw(EST_TokenStream &ts,
   EST_Wave &wv,
   int rate,
@@ -572,25 +725,43 @@ static
 EST_TValuedEnumDefinition<EST_WaveFileType, const char *, EST_WaveFile::Info> wavefile_names[] =
 {
   { wff_none,	{ NULL }, 
-    { FALSE, NULL, NULL, "unknown track file type"} },
+    { FALSE, NULL, NULL, NULL, NULL, "unknown track file type"} },
   { wff_nist,	{ "nist", "timit" }, 
-    { TRUE, EST_WaveFile::load_nist,  EST_WaveFile::save_nist, "nist/timit" } },
+    { TRUE, EST_WaveFile::load_nist,  EST_WaveFile::save_nist,
+      EST_WaveFile::save_nist_header, EST_WaveFile::save_nist_data,
+      "nist/timit" } },
   { wff_est,	{ "est"}, 
-    { TRUE, EST_WaveFile::load_est,  EST_WaveFile::save_est, "est" } },
+    { TRUE, EST_WaveFile::load_est,  EST_WaveFile::save_est,
+      EST_WaveFile::save_est_header, EST_WaveFile::save_est_data,
+      "est" } },
   { wff_esps,	{ "esps", "sd"}, 
-    { TRUE,  EST_WaveFile::load_esps,  EST_WaveFile::save_esps, "esps SD waveform" } },
+    { TRUE,  EST_WaveFile::load_esps,  EST_WaveFile::save_esps,
+      EST_WaveFile::save_esps_header, EST_WaveFile::save_esps_data,
+      "esps SD waveform" } },
   { wff_audlab, { "audlab", "vox"}, 
-    { TRUE,  EST_WaveFile::load_audlab,  EST_WaveFile::save_audlab, "audlab waveform" } },
+    { TRUE,  EST_WaveFile::load_audlab,  EST_WaveFile::save_audlab,
+      EST_WaveFile::save_audlab_header, EST_WaveFile::save_audlab_data,
+      "audlab waveform" } },
   { wff_snd,	{ "snd", "au"}, 
-    { TRUE,  EST_WaveFile::load_snd,  EST_WaveFile::save_snd, "Sun snd file" } },
+    { TRUE,  EST_WaveFile::load_snd,  EST_WaveFile::save_snd,
+      EST_WaveFile::save_snd_header, EST_WaveFile::save_snd_data,
+      "Sun snd file" } },
   { wff_aiff,	{ "aiff" }, 
-    { TRUE,  EST_WaveFile::load_aiff,  EST_WaveFile::save_aiff, "Apple aiff file" } },
+    { TRUE,  EST_WaveFile::load_aiff,  EST_WaveFile::save_aiff,
+      EST_WaveFile::save_aiff_header, EST_WaveFile::save_aiff_data,
+      "Apple aiff file" } },
   { wff_riff,	{ "riff", "wav" }, 
-    { TRUE,  EST_WaveFile::load_riff,  EST_WaveFile::save_riff, "Microsoft wav/riff file" } },
+    { TRUE,  EST_WaveFile::load_riff,  EST_WaveFile::save_riff,
+      EST_WaveFile::save_riff_header, EST_WaveFile::save_riff_data,
+      "Microsoft wav/riff file" } },
   { wff_raw,	{ "raw" }, 
-    { FALSE,  EST_WaveFile::load_raw,  EST_WaveFile::save_raw, "Headerless File" } },
+    { FALSE,  EST_WaveFile::load_raw,  EST_WaveFile::save_raw,
+      EST_WaveFile::save_raw_header, EST_WaveFile::save_raw_data,
+      "Headerless File" } },
   { wff_ulaw,	{ "ulaw", "basic" }, 
-    { FALSE,  EST_WaveFile::load_ulaw,  EST_WaveFile::save_ulaw, "Headerless 8K ulaw  File" } },
+    { FALSE,  EST_WaveFile::load_ulaw,  EST_WaveFile::save_ulaw,
+      EST_WaveFile::save_ulaw_header, EST_WaveFile::save_ulaw_data,
+      "Headerless 8K ulaw  File" } },
   { wff_none,	{NULL} }
 };
 
--- a/speech_class/EST_WaveFile.h
+++ b/speech_class/EST_WaveFile.h
@@ -96,34 +96,54 @@ public:
     bool recognise;
     Load_TokenStream *load;
     Save_TokenStream *save;
+    Save_TokenStream *save_header;
+    Save_TokenStream *save_data;
     const char *description;
   } Info;
 
   static EST_write_status save_nist(SaveWave_TokenStreamArgs);
+  static EST_write_status save_nist_header(SaveWave_TokenStreamArgs);
+  static EST_write_status save_nist_data(SaveWave_TokenStreamArgs);
   static EST_read_status load_nist(LoadWave_TokenStreamArgs);
 
   static EST_write_status save_est(SaveWave_TokenStreamArgs);
+  static EST_write_status save_est_header(SaveWave_TokenStreamArgs);
+  static EST_write_status save_est_data(SaveWave_TokenStreamArgs);
   static EST_read_status load_est(LoadWave_TokenStreamArgs);
 
   static EST_write_status save_esps(SaveWave_TokenStreamArgs);
+  static EST_write_status save_esps_header(SaveWave_TokenStreamArgs);
+  static EST_write_status save_esps_data(SaveWave_TokenStreamArgs);
   static EST_read_status load_esps(LoadWave_TokenStreamArgs);
 
   static EST_write_status save_audlab(SaveWave_TokenStreamArgs);
+  static EST_write_status save_audlab_header(SaveWave_TokenStreamArgs);
+  static EST_write_status save_audlab_data(SaveWave_TokenStreamArgs);
   static EST_read_status load_audlab(LoadWave_TokenStreamArgs);
 
   static EST_write_status save_snd(SaveWave_TokenStreamArgs);
+  static EST_write_status save_snd_header(SaveWave_TokenStreamArgs);
+  static EST_write_status save_snd_data(SaveWave_TokenStreamArgs);
   static EST_read_status load_snd(LoadWave_TokenStreamArgs);
 
   static EST_write_status save_aiff(SaveWave_TokenStreamArgs);
+  static EST_write_status save_aiff_header(SaveWave_TokenStreamArgs);
+  static EST_write_status save_aiff_data(SaveWave_TokenStreamArgs);
   static EST_read_status load_aiff(LoadWave_TokenStreamArgs);
 
   static EST_write_status save_riff(SaveWave_TokenStreamArgs);
+  static EST_write_status save_riff_header(SaveWave_TokenStreamArgs);
+  static EST_write_status save_riff_data(SaveWave_TokenStreamArgs);
   static EST_read_status load_riff(LoadWave_TokenStreamArgs);
 
   static EST_write_status save_raw(SaveWave_TokenStreamArgs);
+  static EST_write_status save_raw_header(SaveWave_TokenStreamArgs);
+  static EST_write_status save_raw_data(SaveWave_TokenStreamArgs);
   static EST_read_status load_raw(LoadWave_TokenStreamArgs);
 
   static EST_write_status save_ulaw(SaveWave_TokenStreamArgs);
+  static EST_write_status save_ulaw_header(SaveWave_TokenStreamArgs);
+  static EST_write_status save_ulaw_data(SaveWave_TokenStreamArgs);
   static EST_read_status load_ulaw(LoadWave_TokenStreamArgs);
 
   static EST_write_status save_alaw(SaveWave_TokenStreamArgs);
--- a/speech_class/EST_wave_io.cc
+++ b/speech_class/EST_wave_io.cc
@@ -294,10 +294,10 @@ enum EST_read_status load_wave_nist(EST_
     return format_ok;
 }
 
-enum EST_write_status save_wave_nist(FILE *fp, const short *data, int offset,
-				     int num_samples, int num_channels, 
+enum EST_write_status save_wave_nist_header(FILE *fp,
+				     int num_samples, int num_channels,
 				     int sample_rate,
-				     enum EST_sample_type_t sample_type, int bo)   
+				     enum EST_sample_type_t sample_type, int bo)
 {
     char h[1024], p[1024];
     const char *t;
@@ -333,13 +333,37 @@ enum EST_write_status save_wave_nist(FIL
     strcat(h, "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"); 
     
     if (fwrite(&h, 1024, 1, fp) != 1)
-	return misc_write_error;
+	    return misc_write_error;
     
+    return write_ok;
+}
+
+
+enum EST_write_status save_wave_nist_data(FILE *fp, const short *data, int offset,
+				     int num_samples, int num_channels,
+				     int sample_rate,
+				     enum EST_sample_type_t sample_type, int bo)
+{
+    if (data == NULL)
+       return write_ok;
+
     return save_raw_data(fp,data,offset,num_samples,num_channels,
 			 sample_type,bo);
     
 }
 
+enum EST_write_status save_wave_nist(FILE *fp, const short *data, int offset,
+				     int num_samples, int num_channels,
+				     int sample_rate,
+				     enum EST_sample_type_t sample_type, int bo)
+{
+    save_wave_nist_header(fp, num_samples, num_channels,
+				      sample_rate, sample_type, bo);
+    return save_wave_nist_data(fp, data, offset,
+				     num_samples, num_channels,
+				     sample_rate, sample_type, bo);
+}
+
 /*=======================================================================*/
 /* EST's own format                                                      */
 /*=======================================================================*/
@@ -412,10 +436,10 @@ enum EST_read_status load_wave_est(EST_T
     return format_ok;
 }
 
-enum EST_write_status save_wave_est(FILE *fp, const short *data, int offset,
-				       int num_samples, int num_channels, 
+enum EST_write_status save_wave_est_header(FILE *fp,
+				       int num_samples, int num_channels,
 				       int sample_rate,
-				       enum EST_sample_type_t sample_type, int bo)   
+				       enum EST_sample_type_t sample_type, int bo)
 {
     fprintf(fp, "EST_File wave\n");
     fprintf(fp, "DataType binary\n");
@@ -427,10 +451,32 @@ enum EST_write_status save_wave_est(FILE
 	fprintf(fp, "ByteOrder %s\n", ((bo == bo_big) ? "10" : "01"));
     
     fprintf(fp, "EST_Header_End\n");
-    
+    return write_ok;
+}
+
+enum EST_write_status save_wave_est_data(FILE *fp, const short *data, int offset,
+				       int num_samples, int num_channels,
+				       int sample_rate,
+				       enum EST_sample_type_t sample_type, int bo)
+{
+    if (data == NULL)
+       return write_ok;
+
     return save_raw_data(fp, data, offset, num_samples, num_channels,
 			 sample_type, bo);
+}
+
+enum EST_write_status save_wave_est(FILE *fp, const short *data, int offset,
+				       int num_samples, int num_channels,
+				       int sample_rate,
+				       enum EST_sample_type_t sample_type, int bo)
+{
+    save_wave_est_header(fp, num_samples, num_channels,
+				         sample_rate, sample_type, bo);
     
+    return save_wave_est_data(fp, data, offset,
+				       num_samples, num_channels,
+				       sample_rate, sample_type, bo);
 }
 
 /*=======================================================================*/
@@ -587,10 +633,9 @@ enum EST_read_status load_wave_riff(EST_
     return format_ok;
 }
 
-enum EST_write_status save_wave_riff(FILE *fp, const short *data, int offset,
-				     int num_samples, int num_channels, 
-				     int sample_rate,
-				     enum EST_sample_type_t sample_type, int bo)   
+enum EST_write_status save_wave_riff_header(FILE *fp, int num_samples,
+                     int num_channels, int sample_rate,
+				     enum EST_sample_type_t sample_type, int bo)
 {
     (void)bo;
     const char *info;
@@ -647,10 +692,35 @@ enum EST_write_status save_wave_riff(FIL
     if (EST_BIG_ENDIAN) data_size = SWAPINT(data_size);
     fwrite(&data_size,1,4,fp);	/* total number of bytes in data */
     
+    return write_ok;
+}
+
+enum EST_write_status save_wave_riff_data(FILE *fp, const short *data,
+                     int offset, int num_samples, int num_channels,
+				     int sample_rate,
+				     enum EST_sample_type_t sample_type, int bo)
+{
+    if (data == NULL)
+       return write_ok;
+
     return save_raw_data(fp,data,offset,num_samples,num_channels,
 			 sample_type,bo_little);
 }
 
+
+enum EST_write_status save_wave_riff(FILE *fp, const short *data, int offset,
+				     int num_samples, int num_channels,
+				     int sample_rate,
+				     enum EST_sample_type_t sample_type, int bo)
+{
+    save_wave_riff_header(fp, num_samples, num_channels, sample_rate,
+				     sample_type, bo);
+
+    return save_wave_riff_data(fp, data, offset, num_samples,
+                        num_channels, sample_rate, sample_type, bo);
+
+}
+
 /*=======================================================================*/
 /* Amiga/Apple AIFF waveform format                                      */
 /* This was constructed using info in AudioIFF1.3.hqx found on the web   */
@@ -787,10 +857,11 @@ enum EST_read_status load_wave_aiff(EST_
     return format_ok;
 }
 
-enum EST_write_status save_wave_aiff(FILE *fp, const short *data, int offset,
-				     int num_samples, int num_channels, 
+
+enum EST_write_status save_wave_aiff_header(FILE *fp,
+				     int num_samples, int num_channels,
 				     int sample_rate,
-				     enum EST_sample_type_t sample_type, int bo)   
+				     enum EST_sample_type_t sample_type, int bo)
 {
     (void)bo;
     const char *info;
@@ -841,16 +912,40 @@ enum EST_write_status save_wave_aiff(FIL
 	data_int = SWAPINT(data_int);
     fwrite(&data_int,1,4,fp);   /* blocksize */
     
-    if ((sample_type == st_short) ||
-	(sample_type == st_uchar))
-	return save_raw_data(fp,data,offset,num_samples,num_channels,
-			     sample_type,bo_big);
+    return write_ok;
+
+}
+
+enum EST_write_status save_wave_aiff_data(FILE *fp, const short *data, int offset,
+				     int num_samples, int num_channels,
+				     int sample_rate,
+				     enum EST_sample_type_t sample_type, int bo)
+{
+
+    if (data == NULL)
+       return write_ok;
+    if ((sample_type == st_short) || (sample_type == st_uchar))
+	    return save_raw_data(fp,data, offset, num_samples, num_channels,
+                             sample_type, bo_big);
     else
     {
 	fprintf(stderr,"AIFF: requested data type not uchar or short\n");
 	return misc_write_error;
     }
-    
+}
+
+
+enum EST_write_status save_wave_aiff(FILE *fp, const short *data, int offset,
+				     int num_samples, int num_channels,
+				     int sample_rate,
+				     enum EST_sample_type_t sample_type, int bo)
+{
+    save_wave_aiff_header(fp, num_samples, num_channels,
+                          sample_rate, sample_type, bo);
+
+    return save_wave_aiff_data(fp, data, offset,
+				     num_samples, num_channels,
+				     sample_rate, sample_type, bo);
 }
 
 /*=======================================================================*/
@@ -896,19 +991,47 @@ enum EST_read_status load_wave_ulaw(EST_
     return format_ok;
 }
 
-enum EST_write_status save_wave_ulaw(FILE *fp, const short *data, int offset,
+enum EST_write_status save_wave_ulaw_header(FILE *fp,
 				     int num_samples, int num_channels,
 				     int sample_rate,
 				     enum EST_sample_type_t sample_type, int bo)
 {
-    (void)sample_rate;
-    (void)sample_type;
+    (void) sample_rate;
+    (void) sample_type;
+    (void) fp;
+    (void) num_samples;
+    (void) num_channels;
+    (void) bo;
+    return write_ok;
+}
+
+enum EST_write_status save_wave_ulaw_data(FILE *fp, const short *data, int offset,
+				     int num_samples, int num_channels,
+				     int sample_rate,
+				     enum EST_sample_type_t sample_type, int bo)
+{
+    if (data == NULL)
+       return write_ok;
+
     return save_wave_raw(fp,data,offset,num_samples,num_channels,
 			 8000,st_mulaw,bo);
+}
 
+enum EST_write_status save_wave_ulaw(FILE *fp, const short *data, int offset,
+				     int num_samples, int num_channels,
+				     int sample_rate,
+				     enum EST_sample_type_t sample_type, int bo)
+{
+    save_wave_ulaw_header(fp, num_samples, num_channels,
+                          sample_rate, sample_type, bo);
 
+    return save_wave_ulaw_data(fp, data, offset,
+				     num_samples, num_channels,
+				     sample_rate, sample_type, bo);
 }
 
+
+
 enum EST_read_status load_wave_alaw(EST_TokenStream &ts, short **data, int
 				    *num_samples, int *num_channels, int *word_size, int
 				    *sample_rate, enum EST_sample_type_t *sample_type, int *bo,
@@ -1061,8 +1184,8 @@ enum EST_read_status load_wave_snd(EST_T
     return read_ok;
 }
 
-enum EST_write_status save_wave_snd(FILE *fp, const short *data, int offset,
-				    int num_samples, int num_channels, 
+enum EST_write_status save_wave_snd_header(FILE *fp,
+				    int num_samples, int num_channels,
 				    int sample_rate, 
 				    enum EST_sample_type_t sample_type, int bo)
 {
@@ -1114,11 +1237,35 @@ enum EST_write_status save_wave_snd(FILE
     if (fwrite(&header, sizeof(header), 1, fp) != 1)
 	return misc_write_error;
 
+    return write_ok;
+}
+
+enum EST_write_status save_wave_snd_data(FILE *fp, const short *data, int offset,
+				    int num_samples, int num_channels,
+				    int sample_rate,
+				    enum EST_sample_type_t sample_type, int bo)
+{
+    if (data == NULL)
+       return write_ok;
+
     /* snd files are always in BIG_ENDIAN (sun) byte order */
     return save_raw_data(fp,data,offset,num_samples,num_channels,
 			 sample_type,bo_big);
 }
 
+
+enum EST_write_status save_wave_snd(FILE *fp, const short *data, int offset,
+				    int num_samples, int num_channels,
+				    int sample_rate,
+				    enum EST_sample_type_t sample_type, int bo)
+{
+    save_wave_snd_header(fp, num_samples, num_channels, sample_rate,
+                         sample_type, bo);
+    return save_wave_snd_data(fp, data, offset, num_samples,
+             num_channels, sample_rate, sample_type, bo);
+}
+
+
 /*=======================================================================*/
 /* CSTR Audlab files (from the last century)                             */
 /* They are always bigendian                                             */
@@ -1230,8 +1377,8 @@ enum EST_read_status load_wave_audlab(ES
     return format_ok;
 }
 
-enum EST_write_status save_wave_audlab(FILE *fp, const short *data, int offset,
-				       int num_samples, int num_channels, 
+enum EST_write_status save_wave_audlab_header(FILE *fp,
+				       int num_samples, int num_channels,
 				       int sample_rate, 
 				       enum EST_sample_type_t sample_type, int bo)
 {
@@ -1271,12 +1418,34 @@ enum EST_write_status save_wave_audlab(F
     fwrite (&fh, sizeof(fh), 1, fp);
     fwrite (&sh, sizeof(sh), 1, fp);
     fwrite (&sd, sizeof(sd), 1, fp);
-    
+    return write_ok;
+}
+
+enum EST_write_status save_wave_audlab_data(FILE *fp, const short *data, int offset,
+				       int num_samples, int num_channels,
+				       int sample_rate,
+				       enum EST_sample_type_t sample_type, int bo)
+{
+    if (data == NULL)
+       return write_ok;
+
     /* write data*/
     return save_raw_data(fp,data,offset,num_samples,num_channels,
 			 st_short,bo_big);
 }
 
+enum EST_write_status save_wave_audlab(FILE *fp, const short *data, int offset,
+				       int num_samples, int num_channels,
+				       int sample_rate,
+				       enum EST_sample_type_t sample_type, int bo)
+{
+    save_wave_audlab_header(fp, num_samples, num_channels,
+                        sample_rate, sample_type, bo);
+    return save_wave_audlab_data(fp, data, offset,
+				       num_samples, num_channels,
+				       sample_rate, sample_type, bo);
+}
+
 /*=======================================================================*/
 /* Entropic ESPS SD files: portable (non-proprietary) method             */
 /*=======================================================================*/
@@ -1367,8 +1536,9 @@ enum EST_read_status load_wave_sd(EST_To
     
 }
 
-enum EST_write_status save_wave_sd(FILE *fp, const short *data, int offset,
-				   int num_samples, int num_channels, 
+
+enum EST_write_status save_wave_sd_header(FILE *fp,
+				   int num_samples, int num_channels,
 				   int sample_rate, 
 				   enum EST_sample_type_t sample_type, int bo)
 
@@ -1393,6 +1563,7 @@ enum EST_write_status save_wave_sd(FILE
 		}
     /* I believe all of the following are necessary and in this order */
     add_field(hdr,"samples",esps_type,num_channels);
+    /* FIXME: What is doing this path here?? */
     add_fea_special(hdr,ESPS_FEA_DIRECTORY,"margo:/disk/disk10/home/awb/projects/speech_tools/main");
     add_fea_special(hdr,ESPS_FEA_COMMAND,
 		    "EDST waveform written as ESPS FEA_SD.\n\
@@ -1408,11 +1579,37 @@ enum EST_write_status save_wave_sd(FILE
     }
     /* lets ignore desired bo and sample type for the time being */
     delete_esps_hdr(hdr);
-    
+    return write_ok;
+}
+
+
+enum EST_write_status save_wave_sd_data(FILE *fp, const short *data,
+                   int offset,
+				   int num_samples, int num_channels,
+				   int sample_rate,
+				   enum EST_sample_type_t sample_type, int bo)
+
+{
+    if (data == NULL)
+       return write_ok;
+
     return save_raw_data(fp,data,offset,num_samples,num_channels,
 			 sample_type,EST_NATIVE_BO);
 }
 
+enum EST_write_status save_wave_sd(FILE *fp, const short *data, int offset,
+				   int num_samples, int num_channels,
+				   int sample_rate,
+				   enum EST_sample_type_t sample_type, int bo)
+
+{
+    save_wave_sd_header(fp, num_samples, num_channels, sample_rate,
+                        sample_type, bo);
+    return save_wave_sd_data(fp, data, offset, num_samples,
+                num_channels, sample_rate, sample_type, bo);
+
+}
+
 /*=======================================================================*/
 /* Raw data files -- unheadered                                          */
 /* THESE FUNCTIONS ARE DIFFERENT FROM THE REST                           */
@@ -1507,21 +1704,151 @@ enum EST_read_status load_wave_raw(EST_T
     return format_ok;
 }
 
-enum EST_write_status save_wave_raw(FILE *fp, const short *data, 
+enum EST_write_status save_wave_raw_header(FILE *fp,
+				    int num_samples, int num_channels,
+				    int sample_rate,
+				    enum EST_sample_type_t sample_type, int bo)
+{
+    return write_ok;
+}
+
+enum EST_write_status save_wave_raw_data(FILE *fp, const short *data,
 				    int offset,
-				    int num_samples, int num_channels, 
+				    int num_samples, int num_channels,
 				    int sample_rate,
-				    enum EST_sample_type_t sample_type, int bo)   
+				    enum EST_sample_type_t sample_type, int bo)
 {
-    (void)sample_rate;
+    if (data == NULL)
+       return write_ok;
     
     return save_raw_data(fp,data,offset,num_samples,num_channels,
 			 sample_type,bo);
 }
 
+enum EST_write_status save_wave_raw(FILE *fp, const short *data,
+				    int offset,
+				    int num_samples, int num_channels,
+				    int sample_rate,
+				    enum EST_sample_type_t sample_type, int bo)
+{
+    (void)sample_rate;
+
+    return save_wave_raw_data(fp, data, offset, num_samples,
+                    num_channels, sample_rate, sample_type, bo);
+}
+
 /***********************************************************************/
 /*                                                                     */
 /* end of file type specific functions                                 */
 /*                                                                     */
 /***********************************************************************/
 
+enum EST_write_status wave_io_save_header(FILE *fp,
+                      const int num_samples, const int num_channels,
+                      const int sample_rate,
+                      const EST_String& stype, const int bo,
+                      const EST_String& ftype)
+{
+    EST_WaveFileType t = EST_WaveFile::map.token(ftype);
+    EST_sample_type_t sample_type = EST_sample_type_map.token(stype);
+    switch(t)
+    {
+        case wff_nist:
+            return save_wave_nist_header(fp, num_samples, num_channels,
+                       sample_rate, sample_type, bo);
+            break;
+        case wff_esps:
+            return save_wave_sd_header(fp, num_samples, num_channels,
+                       sample_rate, sample_type, bo);
+            break;
+        case wff_est:
+            return save_wave_est_header(fp, num_samples, num_channels,
+                       sample_rate, sample_type, bo);
+            break;
+        case wff_audlab:
+            return save_wave_audlab_header(fp, num_samples, num_channels,
+                       sample_rate, sample_type, bo);
+            break;
+        case wff_snd:
+            return save_wave_snd_header(fp, num_samples, num_channels,
+                       sample_rate, sample_type, bo);
+            break;
+        case wff_aiff:
+            return save_wave_aiff_header(fp, num_samples, num_channels,
+                       sample_rate, sample_type, bo);
+            break;
+        case wff_riff:
+            return save_wave_riff_header(fp, num_samples, num_channels,
+                       sample_rate, sample_type, bo);
+            break;
+        case wff_raw:
+            return save_wave_raw_header(fp, num_samples, num_channels,
+                       sample_rate, sample_type, bo);
+            break;
+        case wff_ulaw:
+            return save_wave_ulaw_header(fp, num_samples, num_channels,
+                       sample_rate, sample_type, bo);
+            break;
+        default:
+        case wff_none:
+            cerr << "Can't save wave header to files type " << ftype << endl;
+            break;
+    }
+    return write_ok;
+}
+
+
+enum EST_write_status wave_io_save_data(FILE *fp, const short * data,
+                      const int offset,
+                      const int num_samples, const int num_channels,
+                      const int sample_rate,
+                      const EST_String& stype, const int bo,
+                      const EST_String& ftype)
+{
+    EST_WaveFileType t = EST_WaveFile::map.token(ftype);
+    EST_sample_type_t sample_type = EST_sample_type_map.token(stype);
+    switch(t)
+    {
+        case wff_nist:
+            return save_wave_nist_data(fp, data, offset, num_samples, num_channels,
+                       sample_rate, sample_type, bo);
+            break;
+        case wff_esps:
+            return save_wave_sd_data(fp, data, offset, num_samples, num_channels,
+                       sample_rate, sample_type, bo);
+            break;
+        case wff_est:
+            return save_wave_est_data(fp, data, offset, num_samples, num_channels,
+                       sample_rate, sample_type, bo);
+            break;
+        case wff_audlab:
+            return save_wave_audlab_data(fp, data, offset, num_samples, num_channels,
+                       sample_rate, sample_type, bo);
+            break;
+        case wff_snd:
+            return save_wave_snd_data(fp, data, offset, num_samples, num_channels,
+                       sample_rate, sample_type, bo);
+            break;
+        case wff_aiff:
+            return save_wave_aiff_data(fp, data, offset, num_samples, num_channels,
+                       sample_rate, sample_type, bo);
+            break;
+        case wff_riff:
+            return save_wave_riff_data(fp, data, offset, num_samples, num_channels,
+                       sample_rate, sample_type, bo);
+            break;
+        case wff_raw:
+            return save_wave_raw_data(fp, data, offset, num_samples, num_channels,
+                       sample_rate, sample_type, bo);
+            break;
+        case wff_ulaw:
+            return save_wave_ulaw_data(fp, data, offset, num_samples, num_channels,
+                       sample_rate, sample_type, bo);
+            break;
+        default:
+        case wff_none:
+            cerr << "Can't save wave data to files type " << ftype << endl;
+            break;
+    }
+    return write_ok;
+}
